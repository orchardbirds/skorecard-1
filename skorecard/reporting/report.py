import pandas as pd
import numpy as np
from typing import Union


# TODO: missing should be a separate row


def bucket_table(
    x_original: pd.Series, x_bucketed: pd.Series, y: Union[pd.Series, np.array], epsilon: float = 0.00001
) -> pd.DataFrame:
    """Create a table with results of bucketing.

    Example:

    ```python
    from skorecard import datasets
    from skorecard.bucketers import OptimalBucketer
    from skorecard.reporting import bucket_table

    X, y = datasets.load_uci_credit_card(return_X_y=True)
    X_trans = OptimalBucketer(max_n_bins=4, min_bin_size=0.05).fit_transform(X, y)
    x_original = X['EDUCATION']
    x_bucketed = X_trans['EDUCATION']

    bucket_table(x_original, x_bucketed, y)
    ```
    """
    table = pd.DataFrame()
    table["original"] = x_original
    table["bucket"] = x_bucketed
    table = table.groupby("bucket")["original"].agg(["min", "max", "count"])
    table = table.reset_index()
    # TODO: add more info here, like event rates, etc
    return table


def create_report(
    X: pd.DataFrame,
    y: np.array,
    column: str,
    bucketer,
    # bucketmapping: Optional[BucketMapping] = None,
    epsilon=0.00001,
    verbose=False,
) -> pd.DataFrame:
    """Calculates summary statistics for a bucket generated by a skorecard bucketing object.

    This report currently works for just 1 column at a time.

    Args:
         X (pd.DataFrame): features
         y (np.array): target
         column (str): column for which you want the report
         bucketer: Skorecard bucket object

    Returns:
        df (pandas DataFrame): reporting df
    """
    X = X.copy()
    X_transform = bucketer.transform(X)
    bucket_mapping = bucketer.features_bucket_mapping_[column]

    if bucket_mapping.type != "numerical":
        raise NotImplementedError("Currently supporting only numerical buckets")

    thresholds = bucket_mapping.map
    thresh_mins = thresholds[:-1]
    thresh_max = thresholds[1:]

    bins = np.sort(X_transform[column].unique())

    df = pd.DataFrame(
        {
            "Bin id": bins,
            "Min bin": thresh_mins,
            "Max bin": thresh_max,
            "Count": X_transform[column].value_counts().loc[bins].values,
            "Count (%)": X_transform[column].value_counts(normalize=True).loc[bins].values,
        }
    )

    X_transform["target"] = y

    # Defaults
    tmp = (
        X_transform.groupby([column])["target"]
        .sum()
        .reset_index()
        .rename(columns={column: "Bin id", "target": "Event"})
    )

    # Merge defaults
    df = df.merge(tmp, how="left", on="Bin id")

    df["Non Event"] = df["Count"] - df["Event"]
    # Default rates
    df["Event Rate"] = df["Event"] / df["Count"]  # todo: can we divide by 0 accidentally?

    df["% Event"] = df["Event"] / df["Event"].sum()
    df["% Non Event"] = df["Non Event"] / df["Non Event"].sum()

    df["WoE"] = ((df["% Event"] + epsilon) / (df["% Non Event"] + epsilon)).apply(lambda x: np.log(x))

    df["IV"] = (df["% Event"] - df["% Non Event"]) * df["WoE"]

    if verbose:
        iv_total = df["IV"].sum()
        print(f"IV for {column} = {np.round(iv_total, 4)}")

    return df.sort_values(by="Bin id")
